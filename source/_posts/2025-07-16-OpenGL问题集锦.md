---
title: OpenGL问题集锦
date: 2025-07-16 13:38:39
categories:
- Computer Graphics
- OpenGL
tags: 
- Computer Graphics
- OpenGL
---

# 清屏和Color Mask的顺序
其实很好理解，`glColorMask`是写入的开关，glClear作为`rendering command`，也是要受到`glColorMask`的作用的。但是，
``` c++
glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
```
和
``` c++
glClearColor(1.0f, 1.0f, 1.0f, 1.0f);
glClearDepth(1.0);
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
``` 
有顺序问题。glColorMask、glClearColor、glClearDepth都是设置状态的，都需要在glClear[之前调用](https://wikis.khronos.org/opengl/Framebuffer#Buffer_clearing)。

# glActiveTexture和glBindTexture的依赖
``` c++
glActiveTexture(GL_TEXTURE10);

glBindTexture(GL_TEXTURE_2D, 0) 
```
比如这种，当前使用的纹理单元是GL_TEXTURE10，glBindTexture绑定会导致GL_TEXTURE10解绑或者绑定到其他纹理。如果多个纹理只想绑定一次，但是后续又有绑定需求的代码，需要注意可能存在的相互影响问题。

# 视口大小和FBO大小的匹配
渲染[uvmesh](https://ndotl.wordpress.com/2018/08/29/baking-artifact-free-lightmaps/)的时候，glViewport设置了image unit的宽高，且通过imageStore/gl_FragCoord来写入image unit；但是没有绑定image unit大小一致的FBO（绑定的默认framebuffer），视口的高比默认FBO的高更大，导致渲染场景y正方向的一部分没有渲染。如果是3D视角的场景，通过拖动视角比较好发现这个问题，但是uvmesh是固定坐标范围，不太好发现场景上部分消隐的变化，尤其是隐藏范围比较小的时候。